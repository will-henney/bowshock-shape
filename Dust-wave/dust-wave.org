* Bow waves formed by radiation pressure on dust grains
+ This mini-project has outgrown its original home, which was in [[id:5493D03D-24D5-479B-8C7B-0BE2FCA576EF][Multifactor pair plot of the non-shape parameters]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Stellar-Bowshocks-2017/stellar-bowshocks.org][../Stellar-Bowshocks-2017/stellar-bowshocks.org]]
+ So, I am moving it here to give it room to grow
** Copy dust wave figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='dust-couple-stream-annotate.pdf dust-wave-Rc-R90*.pdf'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Paper1/figs 
  done
#+END_SRC

#+RESULTS:
: Wed Oct  4 11:18:53 CDT 2017
: /Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
: dust-couple-stream-annotate.pdf -> ../papers/Paper1/figs/dust-couple-stream-annotate.pdf
: dust-wave-Rc-R90-error.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90-error.pdf
: dust-wave-Rc-R90.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90.pdf

** Dust grain trajectories
+ The figure of these in the case of zero gas-grain coupling is done in [[id:8EC004CA-32CC-4B41-830C-535FF79B0544][Dust grain trajectories in a central force]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Quadric-shapes/quadric-projected-2017.org][../Quadric-shapes/quadric-projected-2017.org]]
+ [ ] I would like to do some sort of n-body code coupled with a gas code to allow a more realistic model
  + A first approach would be a test-particle approximation, which would avoid the need for the gas code
  + We would have a uniform background gas flow to provide drag, but would ignore the back reaction of the grains on the gas (valid for sufficiently low dust-gas ratio)
  + We could solve this using ~scipy.integrate.odeint~ or ~scipy.integrate.ode~
  + On the axis, for sufficiently weak coupling, I think the trajectories will oscillate between
    1. an inner radius, r_0, where drift speed w \gg inflow speed v_0, allowing grain to decouple and turn from inflow to outflow
    2. an outer radius, r_1, where w = v_0, so grain re-couples and turns from outflow back to inflow again 
  + If density is constant, then w \propto 1/r, so if w_0 is the drift speed at r_0, then r_1 = r_0 w_0 / v_0
  + Although, wouldn’t grain get trapped at r_1?
  + Yes, it turns out that the phase space (x, u) trajectories spiral into (x=r_1, u=0)
*** On-axis numerical solution for trajectories
#+BEGIN_SRC python :eval no :tangle dust-coupling-1d.py
  import sys
  import numpy as np
  from scipy.integrate import odeint
  from matplotlib import pyplot as plt
  import seaborn as sns

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      x, u = y
      dxdt = u
      dudt = 0.5*(x**(-2) - alpha**2 * (u + 1.0))
      return [dxdt, dudt]

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Initial conditions
  y0 = [10.0, -1.0]

  # Coupling parameter
  alpha = 1.0/2.0

  # Time grid
  t = np.linspace(0.0, 60.0, 201)

  soln = odeint(dydt, y0, t, args=(alpha,))

  sns.set_style('white')
  sns.set_color_codes('dark')
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(t, soln[:, 1], label='$u$')
  ax.plot(t, soln[:, 0], label='$x$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend()
  ax.set(xlabel='Time', ylim=[None, 4])

  axp.plot(soln[:, 0], soln[:, 1])
  axp.axhline(0, color='k', lw=0.5)
  axp.set(xlabel='$x$', ylabel='$u$',
          xlim=[None, 5], ylim=[-1, 1])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC shell :results file
python dust-coupling-1d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-1d.pdf]]
*** Two-d solution for trajectories


#+BEGIN_SRC python :eval no :tangle dust_couple_ode.py
  import numpy as np
  from scipy.integrate import odeint

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U + 1.0))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * V)
      return [dXdt, dUdt, dYdt, dVdt]


  def streamline(alpha=1.0/3.0, X0=10.0, Y0=0.0,
                 tstop=60.0, n=201):
      # Vector of initial conditions
      y0 = [X0, -1.0, Y0, 0.0]
      # Time grid
      t = np.linspace(0.0, tstop, n)
      soln = odeint(dydt, y0, t, args=(alpha,))
      return {'t': t, 'b': Y0, 'alpha': alpha,
              'x': soln[:, 0], 'u': soln[:, 1],
              'y': soln[:, 2], 'v': soln[:, 3],}

#+END_SRC

#+BEGIN_SRC python :eval no :tangle dust-coupling-2d.py
  import sys
  from matplotlib import pyplot as plt
  import seaborn as sns
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Impact parameter
  b = 0.001
  stream = streamline(Y0=b, alpha=1.0/2.0)
  sns.set_style('white')
  sns.set_color_codes()
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(stream['t'], stream['u'], label='$u$')
  ax.plot(stream['t'], stream['v'], label='$v$')
  ax.plot(stream['t'], stream['x'], label='$x$')
  ax.plot(stream['t'], stream['y'], label='$y$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend(title=(fr"$\alpha = {stream['alpha']:.3f}$, "
                   f"$b = {b:.3f}$"), ncol=2)
  ax.set(xlabel='Time', ylim=[-3, 5])

  axp.plot(stream['x'], stream['u'], label='$(x, u)$')
  axp.plot(stream['y'], stream['v'], label='$(y, v)$')
  axp.axhline(0, color='k', lw=0.5)
  axp.legend(title='Phase space')
  axp.set(xlabel='$x$, $y$', ylabel='$u$, $v$',
          xlim=[-3, 5], ylim=[-1.1, 1.1])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-coupling-2d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-2d.pdf]]


#+BEGIN_SRC python :eval no :tangle dust-couple-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('white')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  nb = 501
  bgrid = 0.001 + np.linspace(0.0, 5.0, 1001)
  ibspecial = [5, 20, 50, 100, 200, 300]
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-3.99, 3.99]
  ymin, ymax = [0.0, 4.99]
  for alpha, ax in zip(alphas, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []
      for ib, b in enumerate(bgrid):
          s = streamline(X0=5, Y0=b, tstop=30, alpha=alpha, n=10001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin, xmax], [ymin, ymax]])
      rho_m = np.median(H)
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m)
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x, y, '-', color='c', lw=0.5)
      ax.plot(xlocus, ylocus, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      ax.text(1.0, 4.0, 
              fr"$\alpha_\mathrm{{drag}} = {alpha:.2f}$",
              color='y')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan
            
      tabfilename = sys.argv[0].replace('.py', f'-alpha{int(100*alpha):03d}.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab')

  for ax in axes[:, 0]:
      ax.set(ylabel='$y/R_{0}$', ylim=[ymin, ymax])
  for ax in axes[-1, :]:
      ax.set(xlabel='$x/R_{0}$', xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=300)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-stream.py
#+END_SRC

#+RESULTS:
[[file:dust-couple-stream.jpg]]

+ I will now annotate this figure with Graphic.app
  + PDF export in [[file:dust-couple-stream-annotate.pdf]]
*** Shape parameters as function of drag parameter
+ We have written tables of R(\theta) for the inner edge of the dust shells
  + [[file:dust-couple-stream-alpha025.tab]]
  + [[file:dust-couple-stream-alpha050.tab]]
  + [[file:dust-couple-stream-alpha100.tab]]
  + [[file:dust-couple-stream-alpha200.tab]]
+ So we can find R_c and R_90 and plot them as function of \alpha_drag

#+BEGIN_SRC python :eval no :tangle dust-wave-Rc-R90.py
  import sys
  import json
  import numpy as np
  from scipy.interpolate import interp1d
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  import astropy.modeling.fitting
  from astropy.modeling.models import custom_model
  from astropy.modeling.fitting import LevMarLSQFitter
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  @custom_model
  def conic_y_x(x, x0=-3.0, a=5.0, b=3.0):
      s = np.sign(x0 - 1.0)
      return b*np.sqrt(1.0 + s*((x - x0)/a)**2)

  alldata = {}

  fit = LevMarLSQFitter()

  figfile = sys.argv[0].replace('.py', '.pdf')
  sns.set_style('white')
  sns.set_color_codes()

  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  efig, eaxes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))

  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  results = {'alpha': [0.0] + alphas, 'Rc': [2.0], 'R90': [2.0]}
  for alpha, ax, eax in zip(alphas, axes.flat, eaxes.flat):
      astring = f'-alpha{int(100*alpha):03d}.tab'
      alpha_label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
      fitdata = {}
      t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
      dth = np.pi/len(t)
      theta = t['theta'] + 0.5*dth
      # Mask to select only the near-apex region
      m = np.degrees(theta) <= 30.0
      # Reflect through origin to ensure an even function
      thth = np.concatenate([-theta[m][::-1], theta[m]])
      RR = np.concatenate([t['R'][m][::-1], t['R'][m]])
      # Fit polynomial to find R0 and Rc
      a, b, c = np.polyfit(thth, RR, deg=2)
      assert(b == 0.0, 'Linear term should be non-zero, but is not')
      R0 = c
      Rc = 1.0/(1.0 - 2.0*a/c)

      # Find R90 by linear interpolation
      f = interp1d(theta, t['R'], kind='linear')
      R90 = f(0.5*np.pi)/R0
      results['Rc'].append(Rc)
      results['R90'].append(R90)

      R_bow = t['R']/R0
      x_bow = R_bow*np.cos(theta)
      y_bow = R_bow*np.sin(theta)

      # Define the head-fit conic section that corresponds to (Rc, R90)
      arg = 2*Rc - R90**2
      thc = np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))
      head_conic = Conic(A=Rc, th_conic=np.degrees(thc))
      t = head_conic.make_t_array()
      x_head = head_conic.x(t)
      y_head = head_conic.y(t)
      th_head = np.arctan2(y_head, x_head)
      R_head = np.hypot(x_head, y_head)

      # Save the parameters for the head fit
      fitdata['head'] = {'Rc': Rc,
                         'R90': R90,
                         'T': head_conic.b_a**2}

      # Now find a tail-fit conic
      # We only fit the tail between xswitch and xfar
      xswitch, xfar = -1.0, -8.0
      mtail = (x_bow < xswitch) & (x_bow > xfar)
      mfar = (x_bow <= xfar) & (x_bow > -40.0)

      # Try a more direct approach: fit hyperbola with LM
      model = conic_y_x()
      best_model = fit(model, x_bow[mtail], y_bow[mtail])
      r0_tail = best_model.a.value + best_model.x0.value

      x_tail = np.linspace(r0_tail, -30.0, 1000)
      y_tail = best_model(x_tail)
      th_tail = np.arctan2(y_tail, x_tail)
      R_tail = np.hypot(x_tail, y_tail)

      # Save the parameters for the tail fit
      fitdata['tail'] = {'x0': best_model.x0.value,
                         'a': best_model.a.value,
                         'b': best_model.b.value,
                         'r0': best_model.a.value + best_model.x0.value,
                         'T': (best_model.b.value/best_model.a.value)**2}

      # Finally, a third fit to the far tail with a hyperbola
      # model2 = conic_y_x(x0=15.0, a=30.0, b=1.0)
      model2 = conic_y_x(x0=-15.0, a=30.0, b=y_bow[mfar].max())
      best_model2 = fit(model2, x_bow[mfar], y_bow[mfar]) 
      x_far = np.linspace(2.0, -100.0, 1000)
      y_far = best_model2(x_far)
      th_far = np.arctan2(y_far, x_far)
      R_far = np.hypot(x_far, y_far)

      # Save the parameters for the far tail fit
      fitdata['far'] = {'x0': best_model2.x0.value,
                        'a': best_model2.a.value,
                        'b': best_model2.b.value,
                        'r0': best_model2.a.value + best_model2.x0.value,
                        'T': (best_model2.b.value/best_model2.a.value)**2}

      # Stash the fit data in the big dict
      alldata[alpha] = fitdata

      # Plot the bow and the two fits
      ax.axvspan(xfar, xswitch, color='k', alpha=0.05)
      ax.plot(x_bow, y_bow, lw=7, alpha=0.3, label='_nolegend_')
      ax.plot(x_far, y_far, ls='-.', color='m', label="Far tail fit")
      ax.plot(x_tail, y_tail, ls=':', lw=2.5, color='r', label="Tail fit")
      ax.plot(x_head, y_head, ls='--', color='orange', label="Head fit")
      ax.text(-14, 0.8, alpha_label, fontsize='small')

      ax.set_aspect('equal', adjustable='box-forced')

      # And plot the errors
      f_R_tail = interp1d(th_tail, R_tail, bounds_error=False)
      e_tail = (f_R_tail(theta) - R_bow)/R_bow
      f_R_head = interp1d(th_head, R_head, bounds_error=False)
      e_head = (f_R_head(theta) - R_bow)/R_bow
      f_R_far = interp1d(th_far, R_far, bounds_error=False)
      e_far = (f_R_far(theta) - R_bow)/R_bow

      # Find angle that corresponds to x = -1
      th1 = interp1d(x_bow, theta)(xswitch)
      # Find angle that corresponds to x = -8
      th2 = interp1d(x_bow, theta)(xfar)
      mh = theta <= th1
      mt = (theta > th1) & (theta <= th2)
      mtt = theta > th2

      eax.axhline(0.0, lw=3, alpha=0.5, color='b')
      eax.axhspan(-0.01, 0.01, color='b', alpha=0.1, ec='none')
      eax.axvspan(np.degrees(th1), np.degrees(th2), color='k', alpha=0.05)

      # Plot each error curve twice, faintly over the bad zone …
      eax.plot(np.degrees(theta[mt | mtt]), e_head[mt | mtt], label='_nolegend_',
               ls='--', color='orange', alpha=0.3)
      # And strongly over the range it should be fitting
      eax.plot(np.degrees(theta[mh]), e_head[mh], label="Head fit",
               ls='--', color='orange', alpha=1.0)

      # Same for the tail fit, but 3 times since we have a bad zone each side
      eax.plot(np.degrees(theta[mh]), e_tail[mh], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_tail[mtt], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mt]), e_tail[mt], label="Tail fit",
               ls=':', lw=2.5, color='r', alpha=1.0)

      # And now for the far-tail fit as well
      eax.plot(np.degrees(theta[mt]), e_far[mt], label='_nolegend_',
               ls='-.', color='m', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_far[mtt], label="Far tail fit",
               ls='-.', color='m', alpha=1.0)

      eax.text(10.0, -0.04, alpha_label, fontsize='small')


  for ax in axes[-1, :]:
      ax.set(xlim=[-15, 2.5], xlabel='$x/R_0$')
  for ax in axes[:, 0]:
      ax.set(ylim=[0, 8], ylabel='$y/R_0$')
  axes[-1,-1].legend(fontsize='small')

  for eax in eaxes[-1, :]:
      eax.set(xlim=[0.0, 180.0],
              xlabel=r"Polar angle: $\theta$, degrees",
              xticks=[0, 30, 60, 90, 120, 150, 180])
  for eax in eaxes[:, 0]:
      eax.set(ylim=[-0.05, 0.05],
              ylabel=r"Fractional error: $\delta R / R$")
  eaxes[-1,-1].legend(fontsize='small')
  eaxes[-1, 1].text(10.0, -0.9/100, r"$|\delta R/R| < 1\%$", 
                    color='b', fontsize='x-small')

  # print(results)
  #     ax.plot(theta, R, label=fr"${alpha:.2f}$")

  # ax.legend(title=r"$\alpha_\mathrm{drag}$")
  # ax.axhline(2.0, color='k', alpha=0.3, lw=1)
  # ax.axvline(90.0, color='k', alpha=0.3, lw=1)
  # ax.set(xlim=[0.0, 180.0], ylim=[0.0, 14.0],
  #        xlabel=r'$\theta$', ylabel=r'$R$')

  sns.despine(fig)
  fig.tight_layout()
  fig.savefig(figfile)

  sns.despine(efig)
  efig.tight_layout()
  efig.savefig(figfile.replace('.pdf', '-error.pdf'))

  jsonfile = figfile.replace('-Rc-R90.pdf', '-fitdata.json')
  with open(jsonfile, 'w') as f:
      json.dump(alldata, f, indent=4)

  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC sh :results file
python dust-wave-Rc-R90.py
#+END_SRC

#+RESULTS:
[[file:dust-wave-Rc-R90.pdf]]

+ Error figure: [[file:dust-wave-Rc-R90-error.pdf]]
+ JSON data file: [[file:dust-wave-fitdata.json]]

*** Plot diagnostic diagrams for the 3-quadric dust wave fits
+ So this will be like the current Fig 16, but for the \alpha_drag models instead of the carawilkinoids
  + Could I call them /dragoids/?
  + Yes, I think I could
  + Actually, we need to ditch /[an]carawilkinoid/, since it is such a mouthful
  + New terms:
    + /cantoid/ for the CRW shape
    + /ancantoid/ for the anisotropic generalization of ~CRW~
      + Or maybe even /tarangoid/ !!
    + Special cases of ancantoids
      + /proploid/ for \xi = 0.8
      + /jetoid/ for small \xi
+ The graph for the carawilkinoids was done here: [[id:F47926C6-77DB-4797-9101-F83B5E59DA6A][R90 vs Rc for generalized CRW]]
  + It made use of this module: [[id:0483E2CE-E74E-4CFD-89B2-0AE92CCC6217][Utility functions for A, B, and \theta_c]]
  + But that is very specific to those fits and the tortuous process of trying to do analytic matching, which I ended up not using.
  + I think we can do something simpler
+ Some of the necessary equations are in [[id:B3ABBD4B-6A04-415F-8A8D-6A3179EB3686][Projection of Quadrics]]
  + But a lot of the seem to be only in my handwritten notes still
  + I have also copied some functions from [[id:9232DE3C-903E-4D13-8E72-FC2B92D1FF95][Projected R90 versus Rc]]
#+BEGIN_SRC python :eval no :tangle three-quadric-dragoid-R90-vs-Rc.py
  import sys
  import json
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns

  def Rc_prime(inc, Tc, Rc):
      f = np.sqrt(1.0 + Tc*np.tan(inc)**2)
      return Rc * (1 + np.tan(inc)**2) / f / (1.0 + Rc*(f - 1.0) / Tc)

  def Tc_prime(inc, Tc):
      fsquared = 1.0 + Tc*np.tan(inc)**2
      return Tc * (1.0 + np.tan(inc)**2) / fsquared

  def R90_prime(inc, Tc, Rc):
      return np.sqrt(2*Rc_prime(inc, Tc, Rc) - Tc_prime(inc, Tc))

  plotfile = sys.argv[0].replace('.py', '.pdf')

  alldata = json.load(open('dust-wave-fitdata.json'))


  sns.set_style('white')
  sns.set_color_codes('dark')

  fig, ax = plt.subplots(figsize=(5, 5))


  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)

  colors = 'bmgr'

  for (alpha, data), color in zip(alldata.items(), colors):
      # Parameters for head conic
      R0_h = 1.0
      T_h = data['head']['T']
      tilde_Rc_h = data['head']['Rc']
      R90_h = data['head']['R90']
      ax.plot([tilde_Rc_h], [R90_h], 'o', color=color)
      ax.plot(Rc_prime(inc, T_h, tilde_Rc_h),
              R90_prime(inc, T_h, tilde_Rc_h), '--', color=color)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 3.1],
      ylim=[0.0, 3.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC


#+BEGIN_SRC sh :results file
  python three-quadric-dragoid-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:three-quadric-dragoid-R90-vs-Rc.pdf]]


* Utility library ~bow_projection~ for projecting a general shape
+ The plan is to find the plane-of-sky shape (x′, y′) numerically for an arbitrary R(\theta) at a given inclination
+ This will be a check on the multi-quadric 
+ Turns out that I already did a version of this years ago in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/projected/bowfuncs.py][projected/bowfuncs.py]], so I will copy routines from there and modify accordingly
+ [4/9] Plan of work for ~bow_projection.py~ and its applications
  1. [X] Implement analytic R(\theta) functions: paraboloid, wilkinoid, cantoid
  2. [X] Implement \omega(\theta)
     + Test for analytic functions
  3. [X] Implement x’_t, y’_t
     + Plot projected shapes for analytic functions
  4. [X] Implement numerical R(\theta) functions: ancantoid, dragoid
     + [X] Use spline fits to get nice smooth derivatives (use much fewer spline knots than we have theta grid points)
     + [X] Solve the problems I have at \theta = 0 and \theta \to 180
     + [X] Use equation6.py or similar for the ancantoid
     + [X] Read dragoid shapes from json files
  5. [ ] Implement R_c, R_90
     + Deal better with telling if we are outside the bow
     + Plot diagnostic graphs
     + This might be better combined with the following step
  6. [ ] Make a convenience function that will do all that is necessary to get the info for a given shape at a given inclination
     - Find the range of relevant \theta and make an array
     - Find the R_0’, R_c’, R_90’.
       - Use linear interpolation to get the exact values for \theta_90, \theta_0
       - Fit a quadratic to R’(\theta’) 
     - Calculate the (x_t’, y_t’) curve, including the bottom branch and the special points.  Also the \theta’ array
     - Return a dict with all this packaged up
  7. [ ] Include some of these graphs in the paper
  8. [ ] Implement standing wave perturbations
     + Maybe use decorator
  9. [ ] I need to find a better home for this work than the dust-wave file

#+BEGIN_SRC python :tangle bow_projection.py :eval no
  import numpy as np
  from scipy.optimize import brentq
  from scipy.misc import derivative


  # * Module parameters
  #
  # The delta theta that is used in the central difference approximation
  # to the derivative of the R(theta) function.  For optimum balance
  # between round-off and discretization error, this should be of order
  # ~sqrt(eps)~, where ~eps~ is the machine precision
  DX_FOR_NUMERICAL_DERIVATIVE = 3.0*np.sqrt(np.finfo(1.0).resolution)

  # If True, then print out some diagnostic info
  DEBUG = False

  # * Functions to find plane-of-sky shape
  #
  # All these functions should have argument lists of the form:
  #
  # :    theta, [inc], func_R, *args_for_func_R
  #
  # where ~func_R~ has signature ~func_R(theta, *args_for_func_R)~ and
  # ~inc~ is the inclination (for those functions that depend on that).
  #
  # They should also be written as element-wise functions of a vector
  # ~theta~, so no ~if~ statements are allowed, but ~inc~ must be a
  # scalar, as must all of the extra args for ~func_R~.
  #
  def omega(theta, func_R, *args_for_func_R):
      """Find omega = R^{-1} d R/d theta 

  Note that theta may be an array. Any extra arguments are passed to
  `func_R` after `theta`

      """
      def log_R(theta, *args):
          return np.log(func_R(theta, *args))

      return derivative(log_R, theta,
                        dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)


  def sin_phi_t(theta, inc, func_R, *args_for_func_R):
      """Returns sin(phi_t), where phi_t is azimuth along tangent line"""
      om = omega(theta, func_R, *args_for_func_R)
      tan_theta = np.tan(theta)
      if np.tan(inc) == 0.0:
          # Avoid NaNs in the zero inclination case
          return 0.0
      else:
          return np.tan(inc)*(1.0 + om*tan_theta)/(om - tan_theta) 


  def xyprime_t(theta, inc, func_R, *args_for_func_R):
      """Returns observer-frame (x', y') coordinates of tangent line"""
      R = func_R(theta, *args_for_func_R)
      sphi_t = sin_phi_t(theta, inc, func_R, *args_for_func_R)
      cos_theta, sin_theta = np.cos(theta), np.sin(theta)
      xx = cos_theta*np.cos(inc) - sin_theta*sphi_t*np.sin(inc)
      with np.errstate(all='ignore'):
          yy = sin_theta*np.sqrt(1.0 - sphi_t**2)
      return R*xx, R*yy


  def radius_of_curvature(theta, func_R, *args_for_func_R):
      """Returns R_c = (R^2 + R'^2)^{3/2} / |R^2 + 2 R'^2 - R R''| 

  Uses numerical differentiation.  NOT RECOMMENDED SINCE NOT ACCURATE ON
  THE AXIS.  Use `axis_Rc` instead.

      """
      R = func_R(theta, *args_for_func_R)
      dR = derivative(func_R, theta,
                      dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      d2R = derivative(func_R, theta, n=2,
                       dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      return (R**2 + dR**2)**1.5 / np.abs(R**2 + 2*dR**2 - R*d2R)


  # * Projected R_c and R_{90}
  #

  # How close we try to get to the asymptotic theta
  TOLERANCE_THETA_INFINITY = 1.e-6

  def theta_infinity(func_R, *args_for_func_R):
      """Return maximum theta where R its derivative are still finite"""
      th0, dth = 0.0, np.pi
      with np.errstate(all='ignore'):
          # Keep repeating on a finer and finer grid until we get to within
          # the required tolerance
          while dth > TOLERANCE_THETA_INFINITY:
              # This will divide dth by 50 on each iteration
              th, dth = np.linspace(th0, th0 + dth, retstep=True)
              # It is more stringent to insist that omega must be
              # finite, since that needs to be an extra distance (=
              # DX_FOR_NUMERICAL_DERIVATIVE) away from the asymptote in
              # order to calculate the numerical derivative
              om = omega(th, func_R, *args_for_func_R)
              # The largest th for which omega is finite must be within at most
              # (dth + DX_FOR_NUMERICAL_DERIVATIVE) of the true asymptote
              th0 = th[np.isfinite(om)].max()

      return th0



  def theta_0_90(inc, func_R, *args_for_func_R):
      """Return (theta_0, theta_90), corresponding projected x and y axes
      """

      # Easy case first
      if inc == 0.0:
          return 0.0, np.pi/2

      # Second, check tangent line existence
      th_inf = theta_infinity(func_R, *args_for_func_R)
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan, np.nan

      # Otherwise, use root finding

      tani = np.tan(inc)
      sinsq2i = np.sin(2*inc)**2
      cossqi = np.cos(inc)**2

      def _f0(theta):
          """Function that is zero at theta = theta_0"""
          om = omega(theta, func_R, *args_for_func_R)
          return np.sin(theta)*(1.0 - om*tani) - np.cos(theta)*(om + tani)

      def _f90(theta):
          """Function that is zero at theta = theta_90"""
          om = omega(theta, func_R, *args_for_func_R)
          return (1.0/np.tan(theta)
                  - (1.0 - np.sqrt(1.0 + om**2 * sinsq2i))/(2*om*cossqi))

      th_inf = theta_infinity(func_R, *args_for_func_R)
      # If the inclination is too high, then there may be no solution
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan

      # The theta_0 value could be anywhere in range 0 -> th_inf, but we
      # set the lower limit higher than that to avoid some rare errors.
      # This should be alright unless R_c/R_0 < 0.1, which is not true
      # for any of the models I am interested in
      th1, th2 = 0.1*inc, th_inf
      # Make sure we do indeed bracket the root
      assert _f0(th1)*_f0(th2) <= 0.0, f"Unbracketed th0 root: {_f0(th1)}, {_f0(th2)}"
      # And use Brent's method to find the root
      th0 = brentq(_f0, th1, th2)

      # Repeat for the theta_90 value, which must be higher than theta_0
      th1, th2 = th0, th_inf
      assert _f90(th1)*_f90(th2) <= 0.0, f"Unbracketed th90 root: {_f90(th1)}, {_f90(th2)}"
      th90 = brentq(_f90, th1, th2)

      return th0, th90
    
    
  # Number of neighborhood points to use when fitting around projected
  # axes
  N_NEIGHBORHOOD = 8
  # Scale of neighborhood in units of (pi - th0)
  SCALE_NEIGHBORHOOD = 0.01
  # Degree of polynomial used in fitting neighborhood
  DEGREE_POLY_NEIGHBORHOOD = 2

  def characteristic_radii_projected(inc, func_R, *args_for_func_R):
      """Return all the characteristic radii for projected bow shock

  Returns dict of 'R_0 prime', 'tilde R_c prime', 'theta_0', 'tilde R_90
  prime', 'theta_90'

      """

      # Zeroth step, check that we do have a tangent line
      th_inf = theta_infinity(func_R, *args_for_func_R)
      if np.abs(inc) > th_inf - np.pi/2:
          # No tangent line, so return all NaNs
          return {'R_0 prime': np.nan, 'theta_inf': th_inf,
                  'tilde R_c prime': np.nan, 'theta_0': np.nan,
                  'tilde R_90 prime': np.nan, 'theta_90': np.nan}

      # First, the quantities at th0, which is theta on the projected
      # symmetry axis (y' = 0) for this inclination
      th0, th90 = theta_0_90(inc, func_R, *args_for_func_R)

      # Make a grid of theta in the neighborhood of th0
      dth = SCALE_NEIGHBORHOOD*(np.pi - th0)
      th = np.linspace(th0, th0 + dth, N_NEIGHBORHOOD)
      if DEBUG:
          print("theta", th)
          print("R", func_R(th, *args_for_func_R))
          print("sin(phi_t)", sin_phi_t(th, inc, func_R, *args_for_func_R))

      # Now find the tangent line and convert back to polar coordinates
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("x'", xprime)
          print("y'", yprime)
          print("R'", Rprime)
          print("theta'", thprime)
      # Filter out any NaNs in the projected coordinates
      m = np.isfinite(Rprime*thprime)
      # Fit R' with a cubic in (theta')^2, and use the constant and
      # linear coefficients to find the projected R_0 and R_c
      #
      # It seems to be enough to use deg=2 on 8 points
      coeffs = np.polyfit(thprime[m]**2, Rprime[m],
                          deg=DEGREE_POLY_NEIGHBORHOOD)
      R0_prime = coeffs[-1]
      gamma = coeffs[-2]/coeffs[-1]
      Rc_prime = 1./(1. - 2*gamma)
      if DEBUG:
          print("Polynomial coefficients", coeffs/coeffs[-1])


      # Second, the quantities at th90, which is the theta on the projected
      # perpendicular axis (x' = 0)
      th = np.linspace(th90 - dth/2, th90 + dth/2, N_NEIGHBORHOOD)
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("90 x'", xprime)
          print("90 y'", yprime)
          print("90 R'", Rprime)
          print("90 theta'", thprime)
      m = np.isfinite(Rprime*thprime)
      p = np.poly1d(np.polyfit(thprime[m], Rprime[m],
                               deg=DEGREE_POLY_NEIGHBORHOOD))
      R90_prime = p(np.pi/2)/R0_prime

      return {'R_0 prime': R0_prime, 'theta_inf': th_inf,
              'tilde R_c prime': Rc_prime, 'theta_0': th0,
              'tilde R_90 prime': R90_prime, 'theta_90': th90}



  # * Example analytic shape functions
  #

  def wilkinoid_R_theta(theta):
      """Wilkin solution for wind-stream interaction"""
      # Convert to array if scalar
      theta = np.atleast_1d(theta)
      # Equation (9) of Wilkin (1996)
      R = np.sqrt(3*(1.0 - theta/np.tan(theta)))/np.sin(np.abs(theta))
      # Equation is not stable for very small theta, so we use a Taylor
      # expansion instead
      small_angle = np.abs(theta) < 1e-5
      R[small_angle] = 1.0 + 0.2*theta[small_angle]**2
      return R

  def cantoid_R_theta(theta, beta):
      """Cantoid solution from CRW for wind-wind interaction

  Returns R(theta), normalized to the stagnation radius. Extra parameter
  `beta` is the momentum ratio of the two winds.  Note that this will
  not be accurate if beta is too close to zero, but it seems to be OK
  with beta >= 1.e-6.  For lower values than this, the results will be
  almost identical to the Wilkinoid, so `wilkinoid_R_theta` should be
  used instead.

      """

      theta = np.atleast_1d(theta)

      # Approximate solution for theta_1, the polar angle measured from
      # the "other" star
      theta1 = np.sqrt(7.5*(-1.0 + np.sqrt(
          1.0 + 0.8*beta*(1.0 - theta/np.tan(theta)))))
      # Make sure theta1 and theta have the same sign
      theta1 *= np.sign(theta)


      # On-axis (theta = 0) radius to stagnation point, in units of
      # star-star separation D
      R0 = np.sqrt(beta)/(1.0+np.sqrt(beta))

      R = np.where(np.abs(theta + theta1) > np.pi,
                   # theta > theta_inf => no solution
                   np.nan,
                   # theta <= theta_inf => return radius in units of R0
                   np.sin(theta1) / np.sin(theta + theta1) / R0)

      # Replace with Taylor expansion close to axis
      C = (1.0 - beta)/30.0
      gamma = C/(1.0 + np.sqrt(beta)) + (1.0 + 2*np.sqrt(beta))/6
      small_angle = np.abs(theta) < 1.e-5
      R[small_angle] = 1.0 + gamma*theta[small_angle]**2

      return R


  def paraboloid_R_theta(theta):
      """This is the special parabola with Rc = 2"""
      return 2.0 / (1.0 + np.cos(theta))


  def paraboloid_omega_true(theta):
      """Analytic omega for special parabola"""
      return np.sin(theta)  / (1.0 + np.cos(theta))


  # * Non-analytic shape functions
  #
  # These are bow shock shapes for which it is "non-trivial" to
  # calculate each R(theta).  E.g., requiring numerical root finding, so
  # hard to write naturally in an element-wise vector form
  #
  # For efficiency, we therefore calculate R(theta) once on a grid, and
  # then use a spline interpolation for fast subsequent evaluation
  # of R(theta) and its derivative

  import scipy.interpolate

  class _Spline_R_theta(object):
      """Base class for non-analytic shapes

  The R(theta) shape is initialized once on a grid when the class is
  instantiated, and fitted by a B-spline.  The object can then be called
  as a function of theta, which will be very fast since it just
  evaluates the B-spline.

      """

      thgrid = None
      Rgrid = None
      def _init_grid(self, ngrid, **shape_kwds):
          raise NotImplementedError("Override this method in a sub-class")

      def _init_spline(self, kspline, Rmax, smooth):
          """Fit a smoothing spline to the R(theta) grid. 

  We fit B-splines to the parametric [x(theta), y(theta)] representation
  of the bow shock. `kspline` is the order of the splines (default:
  cubic). `Rmax` is the maximum radius to be included in the spline fit.
  `smooth` is the spline smoothing condition (see docs for
  `scipy.interpolate.splprep`).

          """
          mgood = np.isfinite(self.Rgrid) & (self.Rgrid <= Rmax)
          x = self.Rgrid[mgood]*np.cos(self.thgrid[mgood])
          y = self.Rgrid[mgood]*np.sin(self.thgrid[mgood])
          self.spline_tck, u = scipy.interpolate.splprep(
              [x, y], u=self.thgrid[mgood], k=kspline, s=smooth)

      def __call__(self, theta):
          """Evaluate R(theta) from spline interpolation"""
          x, y = scipy.interpolate.splev(theta, self.spline_tck, ext=1)
          # The ext=1 option to splev return 0 for points outside range of theta
          R = np.hypot(x, y)
          # Then we set those out-of-bound points to NaN
          R[(x == 0.0) & (y == 0.0)] = np.nan
          return R

      def __init__(self, ngrid=100, kspline=3, Rmax=100, smooth=0, **shape_kwds):
          """"""
          # Set up grids of theta and R
          self._init_grid(ngrid, **shape_kwds)
          # Set up spline interpolation
          self._init_spline(kspline, Rmax, smooth)


  class Spline_R_theta_from_function(_Spline_R_theta):
      """Spline-interpolated bow shock shape from explicit function

  Extra parameters for initialization: `shape_func` and
  `shape_func_pars`. THIS IS FOR TESTING ONLY!!! It checks that the
  interpolation machinery works for simple shapes. Outside of such
  tests, there is really no need to use the spline interpolation for
  these cases.

      """

      def _init_grid(self, ngrid,
                     shape_func=paraboloid_R_theta,
                     shape_func_pars=()):
          # Include the negative branch so the spline will have the
          # right gradient on the axis
          self.thgrid = np.linspace(-np.pi, np.pi, ngrid)
          self.Rgrid = shape_func(self.thgrid, *shape_func_pars)


  class Spline_R_theta_from_grid(_Spline_R_theta):
      """Spline-interpolated bow shock shape from user-specified arrays

  Extra parameters for initialization: `theta_grid` and `R_grid`.  This
  is the main way that the spline fits will be used.

      """
      def _init_grid(self, ngrid, theta_grid=None, R_grid=None):
          # Note that ngrid is ignored in this implementation
          if theta_grid is not None and R_grid is not None:
              self.thgrid = theta_grid
              self.Rgrid = R_grid
          else:
              raise ValueError("Both theta_grid and R_grid must be specified")


  # * Basic tests of functionality
  #

  if __name__ == "__main__":
      import sys
      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(0.0, np.pi, 501)
      th_dg = np.degrees(th)
      ax.plot(th_dg, omega(th, paraboloid_R_theta),
              label="paraboloid")
      ax.plot(th_dg, omega(th, wilkinoid_R_theta),
              label="wilkinoid")
      for beta in 0.001, 0.01, 0.1:
          ax.plot(th_dg, omega(th, cantoid_R_theta, beta),
                  label=fr"cantoid $\beta = {beta:.3f}$")
      ax.legend(title=r"Analytic $R(\theta)$ functions")
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
      ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
      ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
          xlim=[0, 180],
          ylim=[0.0, 2e2],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      figfile = f"test_{lib_name}_omega.pdf"
      fig.savefig(figfile)
      print(figfile, end='')
#+END_SRC


** Test the ~bow_projection~ library

*** Tests of analytic shapes
**** Basic test of omega(theta) for analytic shape
This is included in the module itself.  Note the ~symlog~ y-axis, which is linear from 0 \to 1 and then logarithmic from 1 \to 200
#+BEGIN_SRC sh :results file
  python bow_projection.py
#+END_SRC

#+RESULTS:
[[file:test_bow_projection_omega.pdf]]

**** Test of \phi_t
#+BEGIN_SRC python :eval no :tangle test_phi_t.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import sin_phi_t, paraboloid_R_theta

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(5, 5))

  th = np.linspace(0.0, np.pi, 501)
  th_dg = np.degrees(th)
  inclinations = [0, 15, 30, 45, 60, 75]
  colors = sns.color_palette(n_colors=len(inclinations))
  for inc_dg, color in zip(inclinations, colors):
      inc = np.radians(inc_dg)
      sphit = sin_phi_t(th, inc, paraboloid_R_theta)
      phit_dg = np.degrees(np.arcsin(sphit))
      ax.plot(th_dg, phit_dg, label=f"inc = {inc_dg:d}", color=color)

  ax.legend(title="paraboloid")
  ax.set(
      xlabel=r"$\theta$",
      ylabel=r"$\phi_t$",
      xlim=[0, 180],
      ylim=[-90, 90],
      xticks=[0, 30, 60, 90, 120, 150, 180],
      yticks=[-90, -60, -30, 0, 30, 60, 90],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_phi_t.py
#+END_SRC

#+RESULTS:
[[file:test_phi_t.pdf]]

**** Test of plane-of-sky shape
#+BEGIN_SRC python :eval no :tangle test_xyprime.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  th = np.linspace(0.0, np.pi, 1001)
  inclinations = [0, 15, 30, 45, 60, 75]
  colors = sns.color_palette(n_colors=len(inclinations))

  for shape_name, ax, R_theta, extra_pars in [
          ["Paraboloid", axes[0, 0], paraboloid_R_theta, ()],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, ()],
          [r"Cantoid $\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,)],
          [r"Cantoid $\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,)],
  ]:
      for inc_dg, color in zip(inclinations, colors):
          inc = np.radians(inc_dg)
          xp, yp = xyprime_t(th, inc, R_theta, *extra_pars)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p, label=fr"$i = {inc_dg:d}^\circ$", color=color)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=shape_name, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime.pdf]]


*** Test of spline fits to analytic shapes

**** R(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline_radius.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 10001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 1001, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 1001, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, spline_func(th), lw=0.5, label=label)
      ax.plot(th_dg, func(th, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')

  ax.legend(title=r"Spline approximations")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$R$",
      xlim=[-180, 180],
      yscale='log',
      ylim=[0.9, 200.0],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline_radius.py
#+END_SRC

#+RESULTS:
[[file:test_spline_radius.pdf]]


**** \omega(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(0, np.pi, 10001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 1001, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 1001, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, omega(th, spline_func), lw=0.5, label=label)
      ax.plot(th_dg, omega(th, func, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')

  ax.legend(title=r"Spline approximations")
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
  ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
      xlim=[0, 180],
      ylim=[0.0, 2e2],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline.py
#+END_SRC

#+RESULTS:
[[file:test_spline.pdf]]

**** (x_t’, y_t’) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_xyprime_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, Spline_R_theta_from_function,
                              paraboloid_R_theta, wilkinoid_R_theta,
                              cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  th = np.linspace(0.0, np.pi, 1001)
  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(n_colors=len(inclinations))

  for label, ax, func, pars, ngrid, s in [
          ["paraboloid", axes[0, 0], paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,), 1001, 0],
          # [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 101, 1e-10],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)

      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          xp, yp = xyprime_t(th, inc, spline_func)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_spline.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_spline.pdf]]



** Dragoid application of ~bow_projection~ library

#+BEGIN_SRC python :eval no :tangle dragoid_shape.py
  import sys
  import numpy as np
  from astropy.table import Table
  from bow_projection import Spline_R_theta_from_grid

  class Dragoid(object):
      def __init__(self, alpha):
          astring = f'-alpha{int(100*alpha):03d}.tab'
          self.label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
          t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
          dth = np.pi/len(t)
          self.thgrid = t['theta'] + 0.5*dth
          self.Rgrid = t['R']/t['R'][0]
          self.thgrid = np.concatenate([-self.thgrid[::-1], self.thgrid])
          self.Rgrid = np.concatenate([self.Rgrid[::-1], self.Rgrid])
          self.splinefit = Spline_R_theta_from_grid(
                theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
          return self.splinefit(theta)

  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      for alpha in [0.25, 0.5, 1.0, 2.0]:
          shape = Dragoid(alpha=alpha)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=shape.label)

      ax.legend(title=r"Dragoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC

**** Test R(\theta) spline fit to dragoid
#+BEGIN_SRC sh :results file
python dragoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_dragoid_shape_radius.pdf]]
**** Test (x_t’, y_t’) for dragoid
#+BEGIN_SRC python :eval no :tangle test_xyprime_dragoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t)
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  th = np.linspace(0.0, np.pi, 1001)
  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(n_colors=len(inclinations))

  for alpha, ax in zip([0.25, 0.5, 1.0, 2.0], axes.flat):
      shape = Dragoid(alpha=alpha)

      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title="Dragoid " + shape.label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_dragoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_dragoid.pdf]]

** Ancantoid application of ~bow_projection~ library

*** Spline fit to ancantoid shape
#+BEGIN_SRC python :eval no :tangle ancantoid_shape.py
  import sys
  import numpy as np
  from bow_projection import Spline_R_theta_from_grid
  sys.path.append("../CRW-shapes")
  import equation6

  DEBUG = False

  class Ancantoid(object):
      def __init__(self, xi, beta, n=101):
          if DEBUG:
              print("Initialising Ancantoid(xi={xi:.2g}, beta={beta:.2g}, n={n})",
                    file=sys.stderr)
          # Use equation6 to find grid of R, theta
          self.thgrid = np.linspace(0.0, np.pi, n)
          self.shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
          self.Rgrid = self.shell.radius(self.thgrid) / self.shell.R0
          if DEBUG:
              print("thgrid =", self.thgrid, file=sys.stderr)
              print("Rgrid = ", self.Rgrid, file=sys.stderr)
          # Then set up the spline fit to the grid points
          self.splinefit = Spline_R_theta_from_grid(
              theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
           return self.splinefit(theta)


  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"


      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      for xi, beta in [[0.8, 0.001],
                       [0.8, 0.01],
                       [0.8, 0.1],
                       [0.4, 0.001],
                       [0.4, 0.01],
                       [0.4, 0.1],]:
          label = fr"$\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
          shape = Ancantoid(xi=xi, beta=beta)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=label)

      ax.legend(title=r"Ancantoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC


**** Test R(\theta) spline fit to ancantoid
#+BEGIN_SRC sh :results file
python ancantoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_ancantoid_shape_radius.pdf]]


**** Test (x_t’, y_t’) for ancantoid
#+BEGIN_SRC python :eval no :tangle test_xyprime_ancantoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t)
  from ancantoid_shape import Ancantoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  th = np.linspace(0.0, np.pi, 1001)
  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(n_colors=len(inclinations))

  for xi, beta, ax in [[0.8, 0.001, axes[0, 0]],
                       [0.8, 0.1, axes[0, 1]],
                       [0.4, 0.001, axes[1, 0]],
                       [0.4, 0.1, axes[1, 1]],]:

      label = fr"Ancantoid $\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
      shape = Ancantoid(xi=xi, beta=beta)

      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_ancantoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_ancantoid.pdf]]


