* Bow waves formed by radiation pressure on dust grains
+ This mini-project has outgrown its original home, which was in [[id:5493D03D-24D5-479B-8C7B-0BE2FCA576EF][Multifactor pair plot of the non-shape parameters]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Stellar-Bowshocks-2017/stellar-bowshocks.org][../Stellar-Bowshocks-2017/stellar-bowshocks.org]]
+ So, I am moving it here to give it room to grow
** Copy dust wave figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='dust-couple-stream-annotate.pdf dust-wave-Rc-R90*.pdf'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Paper1/figs 
  done
#+END_SRC

#+RESULTS:
: Wed Oct  4 11:18:53 CDT 2017
: /Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
: dust-couple-stream-annotate.pdf -> ../papers/Paper1/figs/dust-couple-stream-annotate.pdf
: dust-wave-Rc-R90-error.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90-error.pdf
: dust-wave-Rc-R90.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90.pdf

** Dust grain trajectories
+ The figure of these in the case of zero gas-grain coupling is done in [[id:8EC004CA-32CC-4B41-830C-535FF79B0544][Dust grain trajectories in a central force]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Quadric-shapes/quadric-projected-2017.org][../Quadric-shapes/quadric-projected-2017.org]]
+ [ ] I would like to do some sort of n-body code coupled with a gas code to allow a more realistic model
  + A first approach would be a test-particle approximation, which would avoid the need for the gas code
  + We would have a uniform background gas flow to provide drag, but would ignore the back reaction of the grains on the gas (valid for sufficiently low dust-gas ratio)
  + We could solve this using ~scipy.integrate.odeint~ or ~scipy.integrate.ode~
  + On the axis, for sufficiently weak coupling, I think the trajectories will oscillate between
    1. an inner radius, r_0, where drift speed w \gg inflow speed v_0, allowing grain to decouple and turn from inflow to outflow
    2. an outer radius, r_1, where w = v_0, so grain re-couples and turns from outflow back to inflow again 
  + If density is constant, then w \propto 1/r, so if w_0 is the drift speed at r_0, then r_1 = r_0 w_0 / v_0
  + Although, wouldn’t grain get trapped at r_1?
  + Yes, it turns out that the phase space (x, u) trajectories spiral into (x=r_1, u=0)
*** On-axis numerical solution for trajectories
#+BEGIN_SRC python :eval no :tangle dust-coupling-1d.py
  import sys
  import numpy as np
  from scipy.integrate import odeint
  from matplotlib import pyplot as plt
  import seaborn as sns

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      x, u = y
      dxdt = u
      dudt = 0.5*(x**(-2) - alpha**2 * (u + 1.0))
      return [dxdt, dudt]

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Initial conditions
  y0 = [10.0, -1.0]

  # Coupling parameter
  alpha = 1.0/2.0

  # Time grid
  t = np.linspace(0.0, 60.0, 201)

  soln = odeint(dydt, y0, t, args=(alpha,))

  sns.set_style('white')
  sns.set_color_codes('dark')
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(t, soln[:, 1], label='$u$')
  ax.plot(t, soln[:, 0], label='$x$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend()
  ax.set(xlabel='Time', ylim=[None, 4])

  axp.plot(soln[:, 0], soln[:, 1])
  axp.axhline(0, color='k', lw=0.5)
  axp.set(xlabel='$x$', ylabel='$u$',
          xlim=[None, 5], ylim=[-1, 1])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC shell :results file
python dust-coupling-1d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-1d.pdf]]
*** Two-d solution for trajectories


#+BEGIN_SRC python :eval no :tangle dust_couple_ode.py
  import numpy as np
  from scipy.integrate import odeint

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U + 1.0))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * V)
      return [dXdt, dUdt, dYdt, dVdt]


  def streamline(alpha=1.0/3.0, X0=10.0, Y0=0.0,
                 tstop=60.0, n=201):
      # Vector of initial conditions
      y0 = [X0, -1.0, Y0, 0.0]
      # Time grid
      t = np.linspace(0.0, tstop, n)
      soln = odeint(dydt, y0, t, args=(alpha,))
      return {'t': t, 'b': Y0, 'alpha': alpha,
              'x': soln[:, 0], 'u': soln[:, 1],
              'y': soln[:, 2], 'v': soln[:, 3],}

#+END_SRC

#+BEGIN_SRC python :eval no :tangle dust-coupling-2d.py
  import sys
  from matplotlib import pyplot as plt
  import seaborn as sns
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Impact parameter
  b = 0.001
  stream = streamline(Y0=b, alpha=1.0/2.0)
  sns.set_style('white')
  sns.set_color_codes()
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(stream['t'], stream['u'], label='$u$')
  ax.plot(stream['t'], stream['v'], label='$v$')
  ax.plot(stream['t'], stream['x'], label='$x$')
  ax.plot(stream['t'], stream['y'], label='$y$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend(title=(fr"$\alpha = {stream['alpha']:.3f}$, "
                   f"$b = {b:.3f}$"), ncol=2)
  ax.set(xlabel='Time', ylim=[-3, 5])

  axp.plot(stream['x'], stream['u'], label='$(x, u)$')
  axp.plot(stream['y'], stream['v'], label='$(y, v)$')
  axp.axhline(0, color='k', lw=0.5)
  axp.legend(title='Phase space')
  axp.set(xlabel='$x$, $y$', ylabel='$u$, $v$',
          xlim=[-3, 5], ylim=[-1.1, 1.1])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-coupling-2d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-2d.pdf]]


#+BEGIN_SRC python :eval no :tangle dust-couple-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('white')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  nb = 501
  bgrid = 0.001 + np.linspace(0.0, 5.0, 1001)
  ibspecial = [5, 20, 50, 100, 200, 300]
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-3.99, 3.99]
  ymin, ymax = [0.0, 4.99]
  for alpha, ax in zip(alphas, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []
      for ib, b in enumerate(bgrid):
          s = streamline(X0=5, Y0=b, tstop=30, alpha=alpha, n=10001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin, xmax], [ymin, ymax]])
      rho_m = np.median(H)
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m)
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x, y, '-', color='c', lw=0.5)
      ax.plot(xlocus, ylocus, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      ax.text(1.0, 4.0, 
              fr"$\alpha_\mathrm{{drag}} = {alpha:.2f}$",
              color='y')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan
            
      tabfilename = sys.argv[0].replace('.py', f'-alpha{int(100*alpha):03d}.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab')

  for ax in axes[:, 0]:
      ax.set(ylabel='$y/R_{0}$', ylim=[ymin, ymax])
  for ax in axes[-1, :]:
      ax.set(xlabel='$x/R_{0}$', xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=300)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-stream.py
#+END_SRC

#+RESULTS:
[[file:dust-couple-stream.jpg]]

+ I will now annotate this figure with Graphic.app
  + PDF export in [[file:dust-couple-stream-annotate.pdf]]
*** Shape parameters as function of drag parameter
+ We have written tables of R(\theta) for the inner edge of the dust shells
  + [[file:dust-couple-stream-alpha025.tab]]
  + [[file:dust-couple-stream-alpha050.tab]]
  + [[file:dust-couple-stream-alpha100.tab]]
  + [[file:dust-couple-stream-alpha200.tab]]
+ So we can find R_c and R_90 and plot them as function of \alpha_drag

#+BEGIN_SRC python :eval no :tangle dust-wave-Rc-R90.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  import astropy.modeling.fitting
  from astropy.modeling.models import custom_model
  from astropy.modeling.fitting import LevMarLSQFitter
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  @custom_model
  def conic_y_x(x, x0=-3.0, a=5.0, b=3.0):
      s = np.sign(x0 - 1.0)
      return b*np.sqrt(1.0 + s*((x - x0)/a)**2)


  fit = LevMarLSQFitter()

  figfile = sys.argv[0].replace('.py', '.pdf')
  sns.set_style('white')
  sns.set_color_codes()

  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  efig, eaxes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))

  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  results = {'alpha': [0.0] + alphas, 'Rc': [2.0], 'R90': [2.0]}
  for alpha, ax, eax in zip(alphas, axes.flat, eaxes.flat):
      astring = f'-alpha{int(100*alpha):03d}.tab'
      alpha_label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
      t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
      dth = np.pi/len(t)
      theta = t['theta'] + 0.5*dth
      # Mask to select only the near-apex region
      m = np.degrees(theta) <= 30.0
      # Reflect through origin to ensure an even function
      thth = np.concatenate([-theta[m][::-1], theta[m]])
      RR = np.concatenate([t['R'][m][::-1], t['R'][m]])
      # Fit polynomial to find R0 and Rc
      a, b, c = np.polyfit(thth, RR, deg=2)
      assert(b == 0.0, 'Linear term should be non-zero, but is not')
      R0 = c
      Rc = 1.0/(1.0 - 2.0*a/c)

      # Find R90 by linear interpolation
      f = interp1d(theta, t['R'], kind='linear')
      R90 = f(0.5*np.pi)/R0
      results['Rc'].append(Rc)
      results['R90'].append(R90)

      R_bow = t['R']/R0
      x_bow = R_bow*np.cos(theta)
      y_bow = R_bow*np.sin(theta)

      # Define the head-fit conic section that corresponds to (Rc, R90)
      arg = 2*Rc - R90**2
      thc = np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))
      head_conic = Conic(A=Rc, th_conic=np.degrees(thc))
      t = head_conic.make_t_array()
      x_head = head_conic.x(t)
      y_head = head_conic.y(t)
      th_head = np.arctan2(y_head, x_head)
      R_head = np.hypot(x_head, y_head)


      # Now find a tail-fit conic
      # We only fit the tail between xswitch and xfar
      xswitch, xfar = -1.0, -8.0
      mtail = (x_bow < xswitch) & (x_bow > xfar)
      mfar = (x_bow <= xfar) & (x_bow > -40.0)

      # Try a more direct approach: fit hyperbola with LM
      model = conic_y_x()
      best_model = fit(model, x_bow[mtail], y_bow[mtail])
      # print(best_model.a, best_model.b, best_model.x0)
      r0_tail = best_model.a.value + best_model.x0.value

      # # Add the other branch of the tail
      # xx = np.concatenate([x_bow[mtail][::-1], x_bow[mtail]])
      # yy = np.concatenate([-y_bow[mtail][::-1], y_bow[mtail]])
      # # This is reverse polynomial: x(y)
      # tail_coeffs = np.polyfit(yy, xx, deg=2)
      # assert(tail_coeffs[1] == 0.0, tail_coeffs)
      # ptail = np.poly1d(tail_coeffs)

      x_tail = np.linspace(r0_tail, -30.0, 1000)
      y_tail = best_model(x_tail)
      th_tail = np.arctan2(y_tail, x_tail)
      R_tail = np.hypot(x_tail, y_tail)

      # Finally, a third fit to the far tail with a hyperbola
      # model2 = conic_y_x(x0=15.0, a=30.0, b=1.0)
      model2 = conic_y_x(x0=-15.0, a=30.0, b=y_bow[mfar].max())
      best_model2 = fit(model2, x_bow[mfar], y_bow[mfar]) 
      x_far = np.linspace(2.0, -100.0, 1000)
      y_far = best_model2(x_far)
      th_far = np.arctan2(y_far, x_far)
      R_far = np.hypot(x_far, y_far)

      # Plot the bow and the two fits
      ax.axvspan(xfar, xswitch, color='k', alpha=0.05)
      ax.plot(x_bow, y_bow, lw=7, alpha=0.3, label='_nolegend_')
      ax.plot(x_far, y_far, ls='-.', color='m', label="Far tail fit")
      ax.plot(x_tail, y_tail, ls=':', lw=2.5, color='r', label="Tail fit")
      ax.plot(x_head, y_head, ls='--', color='orange', label="Head fit")
      ax.text(-14, 0.8, alpha_label, fontsize='small')

      ax.set_aspect('equal', adjustable='box-forced')

      # And plot the errors
      f_R_tail = interp1d(th_tail, R_tail, bounds_error=False)
      e_tail = (f_R_tail(theta) - R_bow)/R_bow
      f_R_head = interp1d(th_head, R_head, bounds_error=False)
      e_head = (f_R_head(theta) - R_bow)/R_bow
      f_R_far = interp1d(th_far, R_far, bounds_error=False)
      e_far = (f_R_far(theta) - R_bow)/R_bow

      # Find angle that corresponds to x = -1
      th1 = interp1d(x_bow, theta)(xswitch)
      # Find angle that corresponds to x = -8
      th2 = interp1d(x_bow, theta)(xfar)
      mh = theta <= th1
      mt = (theta > th1) & (theta <= th2)
      mtt = theta > th2

      eax.axhline(0.0, lw=3, alpha=0.5, color='b')
      eax.axhspan(-0.01, 0.01, color='b', alpha=0.1, ec='none')
      eax.axvspan(np.degrees(th1), np.degrees(th2), color='k', alpha=0.05)

      # Plot each error curve twice, faintly over the bad zone …
      eax.plot(np.degrees(theta[mt | mtt]), e_head[mt | mtt], label='_nolegend_',
               ls='--', color='orange', alpha=0.3)
      # And strongly over the range it should be fitting
      eax.plot(np.degrees(theta[mh]), e_head[mh], label="Head fit",
               ls='--', color='orange', alpha=1.0)

      # Same for the tail fit, but 3 times since we have a bad zone each side
      eax.plot(np.degrees(theta[mh]), e_tail[mh], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_tail[mtt], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mt]), e_tail[mt], label="Tail fit",
               ls=':', lw=2.5, color='r', alpha=1.0)

      # And now for the far-tail fit as well
      eax.plot(np.degrees(theta[mt]), e_far[mt], label='_nolegend_',
               ls='-.', color='m', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_far[mtt], label="Far tail fit",
               ls='-.', color='m', alpha=1.0)

      eax.text(10.0, -0.04, alpha_label, fontsize='small')


  for ax in axes[-1, :]:
      ax.set(xlim=[-15, 2.5], xlabel='$x/R_0$')
  for ax in axes[:, 0]:
      ax.set(ylim=[0, 8], ylabel='$y/R_0$')
  axes[-1,-1].legend(fontsize='small')

  for eax in eaxes[-1, :]:
      eax.set(xlim=[0.0, 180.0],
              xlabel=r"Polar angle: $\theta$, degrees",
              xticks=[0, 30, 60, 90, 120, 150, 180])
  for eax in eaxes[:, 0]:
      eax.set(ylim=[-0.05, 0.05],
              ylabel=r"Fractional error: $\delta R / R$")
  eaxes[-1,-1].legend(fontsize='small')
  eaxes[-1, 1].text(10.0, -0.9/100, r"$|\delta R/R| < 1\%$", 
                    color='b', fontsize='x-small')

  # print(results)
  #     ax.plot(theta, R, label=fr"${alpha:.2f}$")

  # ax.legend(title=r"$\alpha_\mathrm{drag}$")
  # ax.axhline(2.0, color='k', alpha=0.3, lw=1)
  # ax.axvline(90.0, color='k', alpha=0.3, lw=1)
  # ax.set(xlim=[0.0, 180.0], ylim=[0.0, 14.0],
  #        xlabel=r'$\theta$', ylabel=r'$R$')

  sns.despine(fig)
  fig.tight_layout()
  fig.savefig(figfile)

  sns.despine(efig)
  efig.tight_layout()
  efig.savefig(figfile.replace('.pdf', '-error.pdf'))

  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC sh :results file
python dust-wave-Rc-R90.py
#+END_SRC

#+RESULTS:
[[file:dust-wave-Rc-R90.pdf]]

+ Error figure: [[file:dust-wave-Rc-R90-error.pdf]]

Try fitting head and tail

#+BEGIN_SRC python
  import sys
  import numpy as np
  import astropy.modeling.fitting
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append('../CRW-shapes')
  import conic_parameters
  import theta_ratio_fit 
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  for alpha in alphas:
      astring = f'-alpha{int(100*alpha):03d}.tab'
      t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
      dth = np.pi/len(t)
      theta = t['theta'] + 0.5*dth
      R_bow = t['R']/t['R'][0]
      x_bow = R_bow*np.cos(theta)
      y_bow = R_bow*np.sin(theta)

      ht = 

#+END_SRC

